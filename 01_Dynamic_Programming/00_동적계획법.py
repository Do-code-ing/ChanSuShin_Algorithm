# [동적계획법 Dynamic Programming]

# sum(n) = 1 + 2 + ... + n
#        = (1 + ... + n-1) + n
#               sum(n-1)

# sum(n) = sum(n-1) + n (sum(1) = 1) <- 재귀 호출 (Divide & Conquer)
# S[n] = S[n-1] + n, S[1] = 1 <- 값을 리스트에 저장, 재사용 (Dynamic Programming)

# 분할 정복과 동적계획법은 굉장히 유사하다.
# 동적계획법은 어떤 테이블에 정보를 저장하고 그 정보를 다시 사용한다는 차이점이 있다.
# 분할 정복은 문제들을 중복되지 않게 잘게 쪼개어 재귀적으로 푼다면,
# 동적계획법은 문제를 분할할 때, 중복이 될 수 있으며 그렇게 푼 문제를 테이블에 저장해
# 큰 문제를 풀기위한 작은 문제의 테이블 정보를 불러와 큰 문제를 푼다.


# [피보나치 넘버] : Fn = Fn-1 + Fn-2, F0 = 0, F1 = 1
# Divide & Conquer
def F(n): 
    if n == 0 or n == 1:
        return n
    
    return F(n-1) + F(n-2)
# 분할 정복시 중복으로 호출되는 F(n-i)가 존재한다.
# 즉 시간이 오래걸린다.

# Dynamic Programming
def F(n):
    f = [0, 1] + [0] * (n-1)
    for i in range(2, n+1):
        f[i] = f[i-1] + f[i-2]
    
    return f
# 피보나치 숫자가 저장된 리스트 f를 확인하여 정답 도출

# 시간 복잡도 차이
# 분할 정복 : O(1.6^n)
# 동적계획법 : O(n)
# 어마어마한 차이다.

# 계단 오르기
# 1, 2, 3, ... , n번째 계단이 있다.
# 한 번에 한 칸씩 올라가거나, 두 칸씩 올라갈 수 있다.
# 1에서 출발할 때,
# 1 -> 2
# 1 -> 3 두 가지 경우의 수가 있다.
# A[n] = 1 -> n 오르는 경우의 수
# A[1] = 1, A[2] = 1, A[3] = 2
# A[1]과 A[2]를 바닥조건이라고 하고,
# n번째에 도달하기 위해서는 n-1에서 올라오거나 n-2에서 올라오거나 두 가지 경우다.
# A[n] = (1 -> n-1)의 경우의 수 + (1 -> n-2)의 경우의수
#           = A[n-1]                = A[n-2]
#       = A[n-1] + A[n-2] 점화식 완성
# 어, 피보나치 숫자네
# 다이나믹 프로그래밍은
# 바닥조건을 만들고, 점화식을 만들어 해결할 수 있다.
def up(n):
    A = [None, 1, 1] + [0] * (n-2) # A[1] = 1, A[2] = 1
    for i in range(3, n+1):
        A[i] = A[i-1] + A[i-2]
    
    return A[n]
# 다이나믹 프로그래밍은 작은 문제에 대한 해답을 저장하고
# 그 해답으로 큰 문제를 해결하고 해답을 저장한다.
# 이것을 반복하면, 단순 재귀호출에 비해 시간 복잡도를 많이 줄일 수 있다.
# 대신 공간 복잡도를 잡아먹는다 ^-^