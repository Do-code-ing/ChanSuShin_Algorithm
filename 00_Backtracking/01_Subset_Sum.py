# [Subset Sum 문제]

# 집합 A와 자연수 S가 주어졌을 때,
# 집합 A에서 몇 개의 원소를 골라서 부분 집합을 만들고,
# 그 부분 집합의 합을 S로 만드는 문제
A = {8, 6, 7, 5, 3, 10, 9}
S = 15
# {8, 7} = 15
# {5, 10} = 15
# {7, 5, 3} = 15
# {6, 9} = 15
# 위의 예시에서는 네 가지 답이 존재하는데, 다 구해도 좋고, 하나만 구해도 좋다.

# [참고]
# 어떤 리스트가 주어졌을 때, 그 리스트에 임의의 구간을 더한 합이 최대가 되도록 구하는 문제와 비슷해 보이지만
# 여기서는 집합이기 때문에 다르다.

# 8을 뽑는 경우, 안 뽑는 경우 즉 0/1 두 가지 경우의 수에 n제곱을 하면 가능한데
# 2^n 은 너무 비효율적이지만, 그렇게 하는거다.

# [pseudo code]
def Subsetsum1(A, S):
    if S == 0: # 아무것도 안 뽑으면 답이니까
        return True # 정답 처리
    if S < 0: # 합을 찾을 수 없으니까
        return False # 오답 처리
    else: # S > 0:
        # pick z from A == A[i]
        z = A[:]
        # 이 A[i]를 뽑는 경우와 안 뽑는 경우 두 가지 경우의 수가 존재한다.
        # 1. 뽑은 경우
        with_ = Subsetsum1(A-{z}, S-z) # 집합 A에서 부분 집합 z를 제외하고, 총 합계 S에서 z값만큼 뺀다.
        # 2. 안 뽑은 경우
        with_out = Subsetsum1(A-{z}, S) # 집합 A에서 부분 집합 z를 제외하고, S는 그대로 한다.
        return with_ or with_out # 둘 중 하나라도 참이면 return True가 된다.

# 무식한 방법이지만,
# 경우에 따라서 모든 2^n개를 살펴보지만,
# 어떻게든 답은 도출한다.

# 집합이 아닌 리스트라고 생각해보자
A = [8, 6, 7, 5, 3, 10, 9]
S = 15
# [pseudo code]
def Subsetsum2(A, i, S): # {A[0], ... , A[i]} 에서 S가 되는 subset이 있다면 True, 아니라면 False를 반환하는 함수
    # 초기 값으로는 Subsetsum2(A, len(A)-1, S)
    if S == 0: # 찾은 경우
        return True
    if S < 0 or i == -1: # 값을 초과하거나, 인덱스가 범위를 벗어난 경우
        return False
    else:
        with_ = Subsetsum2(A, i-1, S-A[i]) # A[i]를 선택한 경우, 1
        with_out = Subsetsum2(A, i-1, S) # A[i]를 선택하지 않은 경우, 0
        return with_ or with_out # 두 가지 경우 중에 한 가지 경우라도 True 라면 True

# 이 방법은 무식한 방법이기 때문에
# 돌아가긴 하지만 빠르게 돌아가진 않는다.
# 오래 걸린다.
# 이것보다 더 잘할 수 있는가?
# 속도를 경이적으로 줄일 순 없다.

# 그런데 가만히 보면,
i = len(A)-1
Subsetsum2(A, i, S) = Subsetsum2(A, i-1, S-A[i]) or Subsetsum2(A, i-1, S)
# 꼴이 나오는데, DP 점화식이다.
DP = []
DP[i][S] = DP[i][S-A[i]] or DP[i-1][S] # DP[i][S] = A[0], ... , A[i] --> S 
# 와 같은 꼴이다.

# 중요한건 DP 테이블을 채우면 수행시간이 얼마나 걸릴까
# N개의 행, S+1개의 열
# 즉 O(NS)의 시간 복잡도가 걸린다.
# N은 입력의 크기라 당연한데, S는 입력 하나임에도, S의 가중치만큼이다.
# 예를 들어,
# A = [1억, 5억, ...] 10개 값
# S = 10억
# 이면 수행시간이 O(10 * 10억)이 된다.
# 즉 수행시간에 왜곡이 생긴다.
# 입력의 크기에 따르지 않은 수행시간이 나오게 되는데
# 이것을 pseudo-polynomial(가짜 다항식)이라 부르는데, 바람직하지 않다.
# S가 크지 않으면 DP는 빠르게 동작하지만, 그렇지 않은 경우엔 엄청나게 오랜 시간과 메모리를 차지할 수 있다.
# 즉 Backtracking으로 풀어야 한다.

# X: 해를 저장하는 리스트
A = [8, 6, 7, 5, 3, 10, 9]
S = 15
X = [1, 0, 1, 0, 0, 0, 0] # 8과 7을 뽑은 경우
X = [0, 0, 0, 1, 0, 1, 0] # 5와 10을 뽑은 경우
# 총 4가지 경우의 수가 있는데,
# 입력 크기 7에서 각각 0/1 두 가지 선택지가 있으므로
# O(2^7)의 시간 복잡도를 갖는다.

# [pseudo code]
def Subsetsum(k): # X[k] -> 0/1
    current_sum = 0 # 현재까지 선택된 A의 값의 합
    if k >= len(A): # X[0], ... , X[n-1] 까지 결정이 됐다면
        if current_sum == S: # 결과가 맞다면
            print(X) # 해 출력
    else: # X[k] 결정
        X[k] = 1 # 뽑는 경우
        Subsetsum(k+1)
        X[k] = 0 # 안 뽑는 경우
        Subsetsum(k+1)

# 이것도 좀 무식해 보이는데
# else: 부분 부터가 중요하다
# list A를 오름차순 정렬하면,
# [3, 5, 6, 7, 8, 9, 10] 이 되는데,
# [1, 0, 1, 0, 1 까지 진행했을 때,
# 3 + 6 + 8 은 S를 넘으므로, 그 뒤까지는 진행하지 않아도 된다.
# if current_sum + A[k] <= S:
#     X[k] = 1
#     Subsetsum(k+1)
# 로 수정해주면 된다.

# [pseudo code]
def Subsetsum(k): # X[k] -> 0/1
    current_sum = 0 # 현재까지 선택된 A의 값의 합
    if k >= len(A): # X[0], ... , X[n-1] 까지 결정이 됐다면
        if current_sum == S: # 결과가 맞다면
            print(X) # 해 출력
    else: # X[k] 결정
        if current_sum + A[k] <= S: # 현재 합에서 다음 숫자를 더할 때, S보다 커지지 않는다면
            X[k] = 1 # 뽑는 경우
            Subsetsum(k+1)
            X[k] = 0 # 안 뽑는 경우도 마찬가지로 어차피 뒤에 숫자들을 뽑아도 S보다 커지기 때문에 같은 if문에 넣는다.
            Subsetsum(k+1)