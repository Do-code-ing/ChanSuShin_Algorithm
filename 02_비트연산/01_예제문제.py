# [예제문제1. n의 이진수의 비트 세기]
def bits_count(n): # n > 0
    cnt = 0 # 비트 수 저장
    while n > 0: # n이 0이 될 때까지 반복
        cnt += 1
        n = n >> 1 # n = n // 2
    return cnt

# 음수의 경우는,
# -13 // 2 = -7
# -7 // 2 = -4
# -4 // 2 = -2
# -2 // 2 = -1
# -1 // 2 = -1
# ...
# 즉 n이 -1이 되기 전까지만 루프를 돌면 된다.


# [예제문제2. n의 이진수의 1의 개수 세기]
def bits_count_one(n): # n > 0
    cnt = 0
    while n > 0:
        if n % 2 == 1: # cnt += n & 1로도 쓸 수 있다.
            cnt += 1   # (n과 1의 공통 부분을 체크하면 되므로)
        n = n >> 1
    return cnt

# 위 두 예제 모두 O(logn)의 시간복잡도를 가지고 있다.
# 예제문제2의 경우, 더 빠른 시간복잡도로 풀 수 있다.
def bits_count_one(n):
    cnt = 0
    while n > 0:
        cnt += 1
        n = n % (n-1)
    return cnt

# n = n % (n-1)의 의미
# n = 01001000 에서,
# 오른쪽부터 처음으로 등장하는 1은 4번째에 등장하는데,
# n-1 = 01000111이 된다.
# 즉, 첫 1의 등장까지의 0과 1이 스왑되고, 나머지는 그대로다.
# 여기서 & 연산을 수행하면,
#   01001000
# & 01000111
#   01000000 이 된다.
# 이 과정을 n이 0이 될 때까지 반복하면,
# while 루프는 1의 개수만큼 돌게 된다.
# 즉, 최악의 경우엔 O(logn)이지만, O(1의 개수)의 시간복잡도를 가지게 된다.


# [예제문제3. 가장 오른쪽 1의 자리값 계산하기]
# n = 01011000 에서,
# 가장 오른쪽 1의 자리값은 2^3, 3번째 자리다.
# n에 not 연산을 수행하면,
# ~n = 10100111 이 된다.
# ~n + 1을 하면(2의 보수를 구하면),
# ~n + 1 = 10101000 이 되는데,
# 여기서 & 연산을 수행하면,
#   01011000
# & 10101000
#   00001000 = 2^3 이 된다.
# n & (~n + 1): O(1)의 시간복잡도를 가진다.

# 응용: BIT(Bit Indexed Tree)
#       Fenwick tree
# BIT의 경우 순열 복원 문제에서 사용된다.
# 한번 보자.
# Fenwick tree의 경우,
# 01011000 = 
# 01000000 +
# 00010000 + 
# 00001000 이다.
# n에 대하여, 오른쪽에서 1이 등장하면 이진수로 표현하고,
# n - 그 이진수를 하고 다시 위의 과정을 반복하여, 이진수들을 모두 구한다.

# [예제문제4. 시간이 없어서..]
# 다음에 시간이 되면 또 하도록 하구욘