# [행렬 곱셈 문제]

# A * B = C
# A = p*q, B = q*r
# C = p*r

# p = i, r = j, q = k
# C[i][j] = A[i][k] * B[k][j]
# C[i][j]를 만들기 위해서는 곱셈을 q번 하고, 덧셈도 q번 한다.
# 대략 2q번 연산을 한다.
# 모든 i와 j에 대해서 하므로
# p * r * (2q)의 기본 연산을 한다.
# O(pqr) 시간 복잡도

# 행렬 3개가 있을 때
# M1 * M2 * M3
# 2*3, 3*2, 2*5
# 방법은 두 가지가 있다.
# ((M1*M2)*M3) : 2*3*2 + 2*2*5 = 32
# (M1*(M2*M3)) : 3*2*5 + 2*3*5 = 60
# 결과는 같은데, 기본 연산의 횟수가 달라진다.
# 그렇다면 첫 번째 방법이 정답이 된다.


# 행렬 곱셈 문제:
# n개의 행렬 M1 * M2 * ... * Mn = M
# p1*p2, p2*p3, ... pn * pn+1 = p1*pn+1
# 기본 연산의 횟수가 최소가 되는 곱셈의 순서를 찾는 문제
# 즉, 괄호치기 문제다.

# n = 4일 때
# (((M1*M2)*M3)*M4)
# ((M1*M2)*(M3*M4))
# ((M1*(M2*M3))*M4)
# (M1*((M2*M3)*M4))
# (M1*(M2*(M3*M4)))
# 총 5가지의 경우의 수가 나오며
# 각 경우의 수에서 나오는 결과 값 중 가장 작은 값이 정답이 된다.

# 문제는 n의 크기가 커질수록 지수적으로 경우의 수가 증가한다.
#                n  3  4  5  6  7 ... n
# 괄호치기 경우의 수  2  5  14 42 132  Cn-1
# Ck =  1  (2k)
#      k+1 ( k) 2k에서 k가지의 경우의 수를 뽑고 k+1로 나눈 수
# 굉장히 큰 수다.
# 어떤 상수 * 4^k이다.
# Catalan이라는 사람이 발견해서 Catalan 수라고 부른다.
# 아무튼 수가 굉장히 커지므로 동적계획법으로 빠르게 풀어보자


# [행렬 곱셈 DP 알고리즘]

# M1 * M2 * ... Mi * Mi+1 * ... * Mn
# 1. 해 분석 -> 부문제 분할
# 2. 부문제 해 -> 점화식 -> 큰 문제 해

# cost(M1 * ... * Mn) = cost(M1 * ... * Mi) + cost(Mi+1 * ... * Mn) + pi * pi+1 * pn+1
# 어떤 Mi를 경계로 두고 위의 식을 수행할 것인가 ?
# 다 해보면 된다.
# cost(M1 * ... * Mn)을 DP[1][n]이라고 한다면
# DP[1][n] = min(DP[1][i] + DP[i+1][n] + p[i] * p[i+1] * p[n+1])
# i = 1, 2, ... , n-1까지 다 해보면 된다.

# DP 테이블: 2차원 리스트
# M1 * ... * M6
# M1 = 2 * 5
# M2 = 5 * 3
# M3 = 3 * 5
# M4 = 5 * 10
# M5 = 10 * 2
# M6 = 2 * 4

# DP 답: DP[1][6] = M1 * ... * M6의 최소 비용
# ij  0  1  2  3  4  5  6
# 0  
# 1                     X
# 2
# 3
# 4
# 5
# 6

# DP[i][j] = min(DP[i][k] + DP[k+1][j] + p[i] * p[k+1] * p[j+1])
# i부터 j까지 곱하는데 필요한 최소 비용

# DP[i][i] = Mi = 0
# ij  0  1  2  3  4  5  6
# 0   
# 1      0              X
# 2         0
# 3            0
# 4               0
# 5                  0
# 6                     0 이 대각선을 기준으로 아래쪽은 i > j이므로 채울 필요가 없다.

# DP[1][6] = min(
#               (DP[1][1] + DP[2][6] + p[1] * p[2] * p[7])
#               (DP[1][2] + DP[3][6] + ...)
#               (DP[1][3] + DP[4][6] + ...)
#               (DP[1][4] + DP[5][6] + ...)
#               (DP[1][5] + DP[6][6] + ...)
#               )

# ij  0  1  2  3  4  5  6
# 0   
# 1      0  A  B  C  D  X
# 2         0           A
# 3            0        B
# 4               0     C
# 5                  0  D
# 6                     0
# 각각의 알파벳 쌍이 필요한대, 이 알파벳 쌍을 채우기 위해서 선행되어야 할 것은
# 0으로 되어있는 0번째 대각선과 그와 인접한 대각선 1을 채워야 한다.

# ij  0  1  2  3  4  5  6
# 0   
# 1      0  A  B  C  D  X
# 2         0  A  B  C  D
# 3            0  A  B  C
# 4               0  A  B
# 5                  0  A
# 6                     0
# A -> B -> C -> D -> X 순으로 대각선을 채울수 있다.

# A부터 차례대로 채워보자
# DP[1][2] = min(DP[1][1] + DP[2][2] + p[1] * p[2] * [3]) = 30
# DP[2][3] = min(DP[2][2] + DP[3][3] + p[2] * p[3] * [4]) = 75
# DP[3][4] = min(DP[3][3] + DP[4][4] + p[3] * p[4] * [5]) = ...
# DP[4][5] = min(DP[4][4] + DP[5][5] + p[4] * p[5] * [6]) = ...
# DP[5][6] = min(DP[5][5] + DP[6][6] + p[5] * p[6] * [7]) = ...

# B의 경우
# DP[1][3] = min(
#         k = 1:(DP[1][1] + DP[2][3] + p[1] * p[2] * p[4]) = 0 + 75 + (2*5*5 = 50) = 123
#         k = 2:(DP[1][2] + DP[3][3] + p[1] * p[3] * p[4]) = 30 + 0 + (2*3*5 = 30) = 60
#               )
# 쭉쭉쭉 채우다보면 
# DP[1][6]에 도달할 수 있다.
# 수행시간은
# DP 테이블의 칸의 개수 N^2 * O(n)
# = O(n^3)

# 앞서 시도했던 4^n보다 n^3이 압도적으로 빠르다.
# LCS에서 최종부문자열을 구한것 처럼,
# 행렬간의 곱셈의 순서 또한 구할 수 있다.
