# [비트연산자 잘~ 활용해보기]
# & = and
# | = or
# ^ = xor
# ~ = not
# >>, << = shift

# +, -, *, / 사칙연산보다 비트연산이 더 빠르다. (어떻게 활용하는가가 중요한 듯)
# 비트연산자는 단위 시간에 수행이 가능하다.

# [주의]
# not, shift 연산은 우리가 직관적으로 생각하는 결과와 반할 때가 있다.
# 예를 들어,
# 음수에 not, shift 연산을 사용하는 경우,

# [not]
# 01101 -> 8 + 4 + 1 = 13
# -13을 표현하는 방법
#   1. 2의 보수 = 1의 보수 + 1 (1의 보수 = not)
#       - ~01101 = 10010
#       - 10010 + 1 = 10011
#   2. sign-magnitude
#       - MSB(Most Significant Bit): 비트의 가장 큰 자리수 (제일 왼쪽)
#       - LSB(Least Significant Bit): 비트의 가장 작은 자리수 (제일 오른쪽)
#       - 1'01101'
#       - MSB가 1이냐 0이냐로 음수인지 양수인지 판단 가능

# 2의 보수를 활용하여 표현한 이진음수도 MSB가 1이냐 0이냐로 판단 가능하다.
# 차이점은 sign_magnitude는 MSB를 제외하고 읽어야 하는 반면,
# 2의 보수는 그 자체로 읽으면 된다.

# 13 = 01101
# ~01101(~13) = 10010
# 10010 + 1 = -13
# -13 - 1 = 10010 + 1 - 1
# -14 = 10010
# 즉, 13의 1의 보수(not)은 -14가 된다.
# 그러나 이 연산에서 사용된 값들을 실제로 어떤 값이라고 생각하고 not을 사용하면 안되고,
# 이진 비트들이 연속적으로 있는데, 그 비트들을 반전시킨다는 목적으로만 사용해야 한다.
# 양수, 음수를 구별하는 과정에서 사용하면 안된다.

# [shift]
# 01101 >> 1
# = ?0110
# ?를 채우는 방식에는 두 가지가 있는데,
# 무조건 0으로 채우는 방법이 있고,
# MSB로 채우는 방법이 있다.
# 위의 예시에서는 MSB가 0이기 때문에 그냥 0으로 채우면 되는데,
# 음수의 경우는 어떻게 할까 ?
# 10011 >> 1
# = ?1001
# 0으로 채우는 shift: logical shift
# MSB로 채우는 shift: arithmetic shift
# Python에서는 arithmetic shift로 쓰인다.

# 왜 Python에서는 arithmetic shift만 정의해서 사용할까 ?
# >> 오른쪽으로 쉬프트의 경우,
# 13 // 2 처럼 2로 정수 나눗셈한 결과와 같다.
# -13 // 2의 경우 -> -6.5 -> -7 (버림을 하기 때문에 더 작은 정수를 취하게 한다.)
# 1001 = 7의 보수 + 1 = -7
# 빈 비트칸에 MSB를 그대로 써야지만 2로 정수 나눗셈을 한 결과가 나온다.

# 음수에 대한 shift 연산에서는 arithmetic shift를 기억하고
# a = a >> k 는 
# a = a // 2**k 와 같다.
# a = a << k 는
# a = a * 2**k 와 같다.
# 위 두 식을 같게하기 위해서 Python에서는 arithmetic shift를 기본 연산으로 제공하고 있다.
# (사실 이해가 잘 안됨)